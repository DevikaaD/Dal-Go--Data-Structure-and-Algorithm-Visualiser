{"ast":null,"code":"const getBubbleSortAnimations = array => {\n  const animations = []; // { comparingElement1, comparingElement2, doSwap, isFinalElement, finalElement }\n  const sortedIndices = []; // Store the sorted indices\n\n  for (let i = 0; i < array.length - 1; i++) {\n    for (let j = 0; j < array.length - i - 1; j++) {\n      // Push animation for comparing 2 elements\n      animations.push(j, j + 1, false, false, -1);\n      if (array[j] > array[j + 1]) {\n        // Swapping values\n        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n        // Push animation for swapping 2 values\n        animations.push(j, j + 1, true, false, -1);\n      }\n    }\n    // Here, the (array.length - 1 - i)th indexed element will be sorted. So we need to change its color.\n    const sortedIndex = array.length - 1 - i;\n    sortedIndices.push(sortedIndex);\n    // Push animation for (array.length - 1 - i)th indexed element which got its sorted position.\n    animations.push(sortedIndex, sortedIndex, false, true, sortedIndex);\n  }\n  // Push animation to know that it's the end of the animation.\n  animations.push(0, 0, false, true, 0);\n  return {\n    animations,\n    sortedIndices\n  };\n};\nconst BubbleSort = (array, animationSpeed) => {\n  // Disabling the buttons so that the animation cannot be interrupted.\n  disableButtons();\n\n  // Getting the animations and sorted indices from the \"getBubbleSortAnimations\" function.\n  const {\n    animations,\n    sortedIndices\n  } = getBubbleSortAnimations(array);\n  for (let i = 0; i < animations.length; i += 5) {\n    // Rest of your code...\n  }\n\n  // Updating the sortedArray state with the sorted indices\n  const sortedArray = sortedIndices.map(index => array[index]);\n  this.setState({\n    sortedArray\n  });\n};\n_c = BubbleSort;\nexport default BubbleSort;\nvar _c;\n$RefreshReg$(_c, \"BubbleSort\");","map":{"version":3,"names":["getBubbleSortAnimations","array","animations","sortedIndices","i","length","j","push","sortedIndex","BubbleSort","animationSpeed","disableButtons","sortedArray","map","index","setState","_c","$RefreshReg$"],"sources":["C:/Users/Devika/Desktop/Dal-Go--Data-Structure-and-Algorithm-Visualiser/Sorting Visualiser/src/SortingVisualizer/SortingAlgorithms/BubbleSort/getBubbleSortAnimations.js"],"sourcesContent":["const getBubbleSortAnimations = (array) => {\r\n  const animations = []; // { comparingElement1, comparingElement2, doSwap, isFinalElement, finalElement }\r\n  const sortedIndices = []; // Store the sorted indices\r\n\r\n  for (let i = 0; i < array.length - 1; i++) {\r\n    for (let j = 0; j < array.length - i - 1; j++) {\r\n      // Push animation for comparing 2 elements\r\n      animations.push(j, j + 1, false, false, -1);\r\n      if (array[j] > array[j + 1]) {\r\n        // Swapping values\r\n        [array[j], array[j + 1]] = [array[j + 1], array[j]];\r\n        // Push animation for swapping 2 values\r\n        animations.push(j, j + 1, true, false, -1);\r\n      }\r\n    }\r\n    // Here, the (array.length - 1 - i)th indexed element will be sorted. So we need to change its color.\r\n    const sortedIndex = array.length - 1 - i;\r\n    sortedIndices.push(sortedIndex);\r\n    // Push animation for (array.length - 1 - i)th indexed element which got its sorted position.\r\n    animations.push(sortedIndex, sortedIndex, false, true, sortedIndex);\r\n  }\r\n  // Push animation to know that it's the end of the animation.\r\n  animations.push(0, 0, false, true, 0);\r\n\r\n  return { animations, sortedIndices };\r\n};\r\n\r\nconst BubbleSort = (array, animationSpeed) => {\r\n  // Disabling the buttons so that the animation cannot be interrupted.\r\n  disableButtons();\r\n\r\n  // Getting the animations and sorted indices from the \"getBubbleSortAnimations\" function.\r\n  const { animations, sortedIndices } = getBubbleSortAnimations(array);\r\n\r\n  for (let i = 0; i < animations.length; i += 5) {\r\n    // Rest of your code...\r\n  }\r\n\r\n  // Updating the sortedArray state with the sorted indices\r\n  const sortedArray = sortedIndices.map((index) => array[index]);\r\n  this.setState({ sortedArray });\r\n};\r\n\r\nexport default BubbleSort;\r\n"],"mappings":"AAAA,MAAMA,uBAAuB,GAAIC,KAAK,IAAK;EACzC,MAAMC,UAAU,GAAG,EAAE,CAAC,CAAC;EACvB,MAAMC,aAAa,GAAG,EAAE,CAAC,CAAC;;EAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IACzC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACI,MAAM,GAAGD,CAAC,GAAG,CAAC,EAAEE,CAAC,EAAE,EAAE;MAC7C;MACAJ,UAAU,CAACK,IAAI,CAACD,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;MAC3C,IAAIL,KAAK,CAACK,CAAC,CAAC,GAAGL,KAAK,CAACK,CAAC,GAAG,CAAC,CAAC,EAAE;QAC3B;QACA,CAACL,KAAK,CAACK,CAAC,CAAC,EAAEL,KAAK,CAACK,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAACL,KAAK,CAACK,CAAC,GAAG,CAAC,CAAC,EAAEL,KAAK,CAACK,CAAC,CAAC,CAAC;QACnD;QACAJ,UAAU,CAACK,IAAI,CAACD,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;MAC5C;IACF;IACA;IACA,MAAME,WAAW,GAAGP,KAAK,CAACI,MAAM,GAAG,CAAC,GAAGD,CAAC;IACxCD,aAAa,CAACI,IAAI,CAACC,WAAW,CAAC;IAC/B;IACAN,UAAU,CAACK,IAAI,CAACC,WAAW,EAAEA,WAAW,EAAE,KAAK,EAAE,IAAI,EAAEA,WAAW,CAAC;EACrE;EACA;EACAN,UAAU,CAACK,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;EAErC,OAAO;IAAEL,UAAU;IAAEC;EAAc,CAAC;AACtC,CAAC;AAED,MAAMM,UAAU,GAAGA,CAACR,KAAK,EAAES,cAAc,KAAK;EAC5C;EACAC,cAAc,EAAE;;EAEhB;EACA,MAAM;IAAET,UAAU;IAAEC;EAAc,CAAC,GAAGH,uBAAuB,CAACC,KAAK,CAAC;EAEpE,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAC7C;EAAA;;EAGF;EACA,MAAMQ,WAAW,GAAGT,aAAa,CAACU,GAAG,CAAEC,KAAK,IAAKb,KAAK,CAACa,KAAK,CAAC,CAAC;EAC9D,IAAI,CAACC,QAAQ,CAAC;IAAEH;EAAY,CAAC,CAAC;AAChC,CAAC;AAACI,EAAA,GAdIP,UAAU;AAgBhB,eAAeA,UAAU;AAAC,IAAAO,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}